lock lab

Part 1

该部分主要考虑空闲块分配的竞争,由于只存在一个单链表,多个cpu在同时想要分配块的时候就会造成竞争
因此,考虑一个cpu维护一个链表,同时用一个锁进行维护,也就是将当前一个空闲块链表对象改为一个具有NCPU元素的数组

初始化时(简单起见)可以考虑直接全部分配给当前cpu

kalloc时,若是当前维护的空闲链表为空,则挨个访问其他空闲链表(先获取相关锁),寻找一个空闲块

kfree时根据当前cpu,将释放后的空闲块加到当前cpu维护的空闲块中




Part 2

本部分考虑读写时磁盘缓存块的竞争, xv6维护一个双向链表以及一个锁来实现,因此当多个cpu同时查找时,必然引起竞争
因此,可以为该部分维护一个seperate chaining hashtable,同时一个桶由一个锁保证

首先初始化,参考xv6原来的代码,循环处理每一个桶, 同时在buf里添加一个时间戳变量

bget处理:
(1)
首先获取blockno对应桶的锁,然后查看是否缓存有的话,引用+1,更新时间戳,解锁返回
没缓存的话,查看是否有空闲块,有的话设置,引用置1,更新时间戳,解锁返回
(2)
该桶里既没有空闲块也没有缓存,需要去其他地方寻找
解锁该桶,获取全局锁,锁住该桶 --- (主要是为了避免死锁)
再次执行(1),主要是考虑到时间中断发生在该桶解锁之后,获取全局锁之前.另一个进程也可能查找该块,从而造成两份拷贝,不过本测试用例没有测试这种情况,所以可以不执行该块

依次获取其他桶的锁,遍历是否有空闲块,有的话 设置,引用置1,更新时间戳, 从原链表删去该节点,在新链表上添加该节点, 解锁返回

若到此仍然没有找到空闲块,说明读写的进程有点多,使用LRU,evict 一个
获取所有的桶的锁,比对时间戳,最小的那个被驱逐,然后设置,引用置1,更新时间戳, 从原链表删去该节点,在新链表上添加该节点, 解锁返回 ---- 这里evict好像对测试没什么用,不要这段代码也可以直接通过

(有点疑惑evict之后的块置1的话不确定是否之前指向该块的指针还在使用...不过测试用例好像就没执行到这里)


提示: 根据测试用例来的话,全局锁没必要,时间戳也没必要,必要的只是:
	锁住blockno对应的桶,查看是否缓存,查看该桶是否有空闲块
	依次遍历其他桶,找空闲块,即锁住一个桶,遍历,找到空闲块就设置解锁返回,反之解锁当前桶,然后下一个桶



