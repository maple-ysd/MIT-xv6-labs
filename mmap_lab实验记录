mmap lab

本次实验主要是实现虚拟内存文件映射,核心思想就是分配一段虚拟内存地址,但是不分配物理地址,直到读或者写的时候产生pagefault才分配相应的物理页,并拷贝文件到该页到该物理页, 最后根据该页是否共享考虑是否要写回文件

按照提示一步一步来差不多就可以实现了(当然细节很重要)
1  _mmaptest添加到UPROGS, ...跟之前的实验基本一样,添加一系列东西以在qemu下面能运行mmaptest
2  usertrap里添加产生读或者写pagefault的处理,可以先直接kill,后面再写
3  在proc.h里添加一个结构VMA, 然后在proc里添加一个VMA对象数组(根据提示取16即可,当然搞成链表也无可厚非)
4  实现mmap,这个直接增加p->sz就可以实现虚拟地址的分配,同时在VMA结构数组里记录相应的信息,记得增加文件file里的ref计数,filedup可以实现
至此,就可以运行第一个mmap了
5  usertrap里添加pagefault处理,分配物理页,通过readi将文件读到相应的虚拟地址处, 然后就可以运行到munmap
6  实现munmap,记住,uvmunmap中间虚拟页,要么是下端,上端,要么就是VMA对象所指的整个区域,不能出现洞,当munmap VMA对象所指的整个区域时,记得减少文件的引用计数,(写回可参考filewrite)
7  理想情况下,当VMA flag为MAP_SHARED, 且PTE_D为置位即dirty位,才需要写回,不过这里简单起见,只要MAP_SHARDE就写回.dirty test应该可以通过了
8  修改exit,像munmap一样取消映射, 然后exit test应该也可以了
9  修改fork, 给fork的进程拷贝VMA数组,写时复制在这里就不实现了

至此基本完事,然后该添加的声明,添加上就行了,缺哪加哪

注意:记得修改uvmunmap, uvmcopy,简单的将panic改为continue即可,类似于lazy lab

遇到的一个问题,卡了稍微久了些,(源于没仔细看测试用例的提示),即 not-mapped unmap测试,
这就要求在写回之前判断待写回的页是否是一个已分配页,如果不是,直接返回就行...一直以为是自己writei参数错了检查了一遍又一遍,最后都有点写不下去了,休息了下回来简单看了下测试用例,自己果然还是有点二....not-mapped unmap已经很明确的表达了意思,就是接下来munmap要测试的页还没有分配,所以在写回之前一定要判断.......(小忧伤,,,不过还是找到了,哈哈哈)
