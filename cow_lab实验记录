COW Lab

核心思路:
本实验主要是实现写时复制(copy-on-write),即fork时,只是简单的拷贝一下页表,并将父进程与子进程的写标志位抹去,标记为只读,同时标记为COW(意味着这是一个写时复制页)
然后当pagefault时,需要将缺失的页拷贝一份出来并回复写标志位,抹去COW位
用户状态时缺页将进入trap.c处理,内核copyout也会导致缺页,但不会进入trap.c, 因此需要提前特殊处理---拷贝缺失页(COW标记时)以避免缺页
另外就是页的删除,添加物理页引用计数,使得当且进当引用计数变为0时删除

步骤:
        riscv.h里添加一个宏定义 PTE_COW        
        
	kalloc里添加一个结构对象refcnt, 包含一个计数物理内存数组
	kinit里初始化该结构体refcnt, 数组元素置0
	kalloc里给每个分配的物理页引用计数置1
	kfree里减少引用计数,当引用计数不大于0时,删除该页,反之仅减少引用计数即可
	定义两个辅助函数,increase_ref引用计数+1, get_ref获取引用计数
	
	uvmcopy里删去物理页的分配, 更新标记位,引用计数+1
	
	copyout里,当引用计数大于1时, 分配一个新物理页,拷贝一份,更改标记位,kfree减少引用计数
	          当引用计数不大于1时直接更改标记位即可
        trap.c里添加当r_scause()==15即写缺页的情况,同copyout相似的处理
        
        最后添加相应的声明即可.

总的来说该实验不是很难的(至少思路上不是很难),然而遇上bug就很难说了...(伤心事...哭泣哭泣...)
哈哈,不管咋说,总算搞出来了...
