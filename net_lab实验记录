net lab

这个实验主要是实现两个函数,一个发包,一个收包

发包:
将mbuf内容填到tx_ring里,释放上一个mbuf,保存现在的mbuf指针以备将来释放用

收包:
循环处理
如果收包完成,将mbuf发给网络协议栈
然后创建一个新的mbuf等待下一轮接收

上锁的处理还不是很清楚...
视频最后一节说,如果上锁的话,会造成死锁,也就是panic(这样确实会出现...),视频里的意思是收到一个包以后会引发中断,继而调用e1000_receive...函数,receive调用next_rx...,然后调用e1000_transmit
因此如果e1000_receive函数也上锁就会出现获取同一个锁两次,进而panic
不过不是很理解,因为没有看到next_rx以及之后的函数哪里调用了e1000_transmit
另外提到的一点就是一次只能一个程序进入中断处理程序,这一点倒是似乎可以解释为什么不需要锁,因为在某个时间一个cpu执行了中断处理程序,执行过程中就不会再有其他中断,也就没有并行所以不需要锁...

